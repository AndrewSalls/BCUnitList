import ORB_MAP from"../../assets/orb-map.js";import SETTINGS from"../../assets/settings.js";import{getTraitSpecificMult,getAbilityOrb,getDesiredLevel,getEffectOrb,getLevelStatMult,getTalentStatMod,getTreasurePercent,getUnitTraitTargets,hasAbility}from"./calculate-stat-mult.js";export const CALCULATOR_LEVEL_OPTIONS={LEVEL_CURRENT:0,LEVEL_1:1,LEVEL_30:2,LEVEL_50:3,LEVEL_MAX:4};export const DEFAULT_CALCULATOR_OPTIONS={targetTraits:[],targetSubTraits:[],testLevelValue:CALCULATOR_LEVEL_OPTIONS.LEVEL_CURRENT,includeTalents:!0,includeOrbs:!0,eocChapterPrice:2,talentIgnoreForm:!1};export function calculateCost(initialValue,updatedData,fixedData,calculatorOptions=DEFAULT_CALCULATOR_OPTIONS){let cost=initialValue;return cost-=getTalentStatMod("Cost_Down",fixedData,updatedData,calculatorOptions.talentIgnoreForm),1===calculatorOptions.eocChapterPrice?cost=Math.ceil(2*cost/3):3===calculatorOptions.eocChapterPrice&&(cost=Math.ceil(4*cost/3)),cost}export function calculateHealth(initialValue,updatedData,fixedData,calculatorOptions=DEFAULT_CALCULATOR_OPTIONS){const shieldMult=1+.5*getTreasurePercent("Legendary Cat Shield","eoc"),usedLevel=getDesiredLevel(calculatorOptions.testLevelValue,updatedData.level+updatedData.plus_level,fixedData);let health=getLevelStatMult(initialValue,usedLevel,fixedData.id,fixedData.rarity,shieldMult);health*=getTraitSpecificMult(fixedData,updatedData,calculatorOptions,"def");for(const subTrait of calculatorOptions.targetSubTraits)hasAbility(`${subTrait}_Slayer`,fixedData,updatedData,calculatorOptions.includeTalents,calculatorOptions.talentIgnoreForm)&&(health*=SETTINGS.subTraitEffectMult.def[`${subTrait}_Slayer`]);if(calculatorOptions.includeOrbs&&calculatorOptions.targetSubTraits.includes("Colossus")&&(health*=getAbilityOrb("Colossus Slayer",updatedData).reduce((prev,curr)=>Math.max(prev,ORB_MAP.type_mults.def.Colossus_Slayer[curr.rank]),1)),calculatorOptions.includeTalents&&(health*=1+getTalentStatMod("Defense",fixedData,updatedData,calculatorOptions.talentIgnoreForm)),calculatorOptions.includeOrbs){health*=getEffectOrb("Defense",calculatorOptions.targetTraits,updatedData).reduce((prev,next)=>prev+ORB_MAP.type_mults.def.Defense[next.rank],1)}return Math.max(1,Math.floor(health))}export function calculateDamage(initialValue,updatedData,fixedData,calculatorOptions=DEFAULT_CALCULATOR_OPTIONS){if(calculatorOptions.targetTraits.length>0&&hasAbility("Restricted_Target",fixedData,updatedData,calculatorOptions.includeTalents,calculatorOptions.talentIgnoreForm)&&getUnitTraitTargets(fixedData,updatedData,calculatorOptions.includeTalents,calculatorOptions.talentIgnoreForm).every(t=>!calculatorOptions.targetTraits.includes(t)))return 0;const swordMult=1+.5*getTreasurePercent("Legendary Cat Sword","eoc"),usedLevel=getDesiredLevel(calculatorOptions.testLevelValue,updatedData.level+updatedData.plus_level,fixedData);let damage=getLevelStatMult(initialValue,usedLevel,fixedData.id,fixedData.rarity,swordMult);damage*=getTraitSpecificMult(fixedData,updatedData,calculatorOptions,"atk");for(const subTrait of calculatorOptions.targetSubTraits)hasAbility(`${subTrait}_Slayer`,fixedData,updatedData,calculatorOptions.includeTalents,calculatorOptions.talentIgnoreForm)&&(damage*=SETTINGS.subTraitEffectMult.atk[`${subTrait}_Slayer`]);if(calculatorOptions.includeOrbs&&calculatorOptions.targetSubTraits.includes("Colossus")&&(damage*=getAbilityOrb("Colossus Slayer",updatedData).reduce((prev,curr)=>Math.max(prev,ORB_MAP.type_mults.atk.Colossus_Slayer[curr.rank]),1)),calculatorOptions.includeTalents&&(damage*=1+getTalentStatMod("Attack",fixedData,updatedData,calculatorOptions.talentIgnoreForm)),calculatorOptions.includeOrbs){damage+=getEffectOrb("Attack",calculatorOptions.targetTraits,updatedData).reduce((prev,next)=>prev+ORB_MAP.type_mults.atk.Attack[next.rank],0)*initialValue}return Math.max(1,Math.floor(damage))}export function calculateKnockbacks(initialValue,_updatedData,_fixedData,_calculatorOptions=DEFAULT_CALCULATOR_OPTIONS){return initialValue}export function calculateRechargeTime(initialValue,updatedData,fixedData,calculatorOptions=DEFAULT_CALCULATOR_OPTIONS){let output=initialValue;output-=Math.round(30*getTreasurePercent("Relativity Clock","eoc"))/30;const abilityIndex=SETTINGS.abilities.abilityNames.indexOf("Research"),researchLevels=(window.localStorage.getItem("abo")?.split("-")??[])[abilityIndex].split("+");return output-=.2*(parseInt(researchLevels[0])+parseInt(researchLevels[1])-1),output-=Math.round(30*getTalentStatMod("Recover_Speed",fixedData,updatedData,calculatorOptions.talentIgnoreForm))/900,Math.max(2,output)}export function calculateRange(initialValue,_updatedData,_fixedData,_calculatorOptions=DEFAULT_CALCULATOR_OPTIONS){return initialValue}export function calculateSpeed(initialValue,updatedData,fixedData,calculatorOptions=DEFAULT_CALCULATOR_OPTIONS){let speed=initialValue;return speed+=getTalentStatMod("Move_Speed",fixedData,updatedData,calculatorOptions.talentIgnoreForm),speed}