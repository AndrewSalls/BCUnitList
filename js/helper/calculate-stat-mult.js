import ORB_MAP from"../../assets/orb-map.js";import SETTINGS from"../../assets/settings.js";import TALENT_GROWTH_MAP from"../../assets/talent-growth.js";import{RARITY}from"../data/unit-data.js";import{CALCULATOR_LEVEL_OPTIONS}from"./calculate-stats.js";export function getLevelStatMult(baseStat,totalLevel,id,rarity,treasureMult){let bp1=1/0,bp2=1/0;if(`${id}`in SETTINGS.statGrowth.unique)bp1=SETTINGS.statGrowth.unique[id]?.[0]??bp1,bp2=SETTINGS.statGrowth.unique[id]?.[1]??bp2;else{if(`${id}`in SETTINGS.statGrowth.P2W)return getP2WStatMult(baseStat,totalLevel,SETTINGS.statGrowth.P2W[id],treasureMult);bp1=SETTINGS.statGrowth.rarity[rarity]?.[0]??bp1,bp2=SETTINGS.statGrowth.rarity[rarity]?.[1]??bp2}let levelMult=.2*Math.min(bp1,totalLevel)+.8;return totalLevel>bp1&&(levelMult+=.1*(Math.min(bp2,totalLevel)-bp1),totalLevel>bp2&&(levelMult+=.05*(totalLevel-bp2))),Math.floor(Math.round(baseStat*levelMult)*treasureMult)}export function getP2WStatMult(baseStat,totalLevel,statObj,treasureMult){totalLevel>statObj[statObj.length-1][0]&&console.error("Missing stat growth for P2W unit");let levelMult=1-statObj[0][1],prevGrowthLevel=0;for(let x=0;x<statObj.length&&statObj[x][0]>=totalLevel;x++)levelMult+=(Math.min(totalLevel,statObj[x][0])-prevGrowthLevel)*statObj[x][1],prevGrowthLevel=statObj[x][0];return Math.floor(Math.round(baseStat*levelMult)*treasureMult)}export function getTreasurePercent(treasureName,chapterAbbr){const treasureIndex=SETTINGS.chapters[chapterAbbr].treasureNames.indexOf(treasureName),treasureLevelStartPos=3*treasureIndex,numTreasures=SETTINGS.chapters[chapterAbbr].treasurePartCount[treasureIndex];let sum=0;for(let x=0;x<SETTINGS.chapters[chapterAbbr].numberChapters;x++){const treasureLevels=window.localStorage.getItem(`${chapterAbbr}_${x}`)?.split("-")??[],bronzeAmt=parseInt(treasureLevels[treasureLevelStartPos]),silverAmt=parseInt(treasureLevels[treasureLevelStartPos+1]),goldAmt=parseInt(treasureLevels[treasureLevelStartPos+2]);bronzeAmt+silverAmt+goldAmt===numTreasures&&(sum+=bronzeAmt+2*silverAmt+3*goldAmt)}return sum/(3*numTreasures)}export function getDesiredLevel(levelOption,currentLevel,unitData){switch(levelOption){case CALCULATOR_LEVEL_OPTIONS.LEVEL_1:return 1;case CALCULATOR_LEVEL_OPTIONS.LEVEL_30:return 30;case CALCULATOR_LEVEL_OPTIONS.LEVEL_50:return 50;case CALCULATOR_LEVEL_OPTIONS.LEVEL_CURRENT:return currentLevel;case CALCULATOR_LEVEL_OPTIONS.LEVEL_MAX:return unitData.level_cap.MaxLevel+unitData.level_cap.MaxPlusLevel;default:return console.error(`Unexpected CALCULATOR_LEVEL_OPTIONS value: ${levelOption}`),-1}}export function getTraitSpecificMult(fixedData,updatedData,calculatorOptions,statType){const unitTargetTraits=getUnitTraitTargets(fixedData,updatedData,calculatorOptions.includeTalents,calculatorOptions.talentIgnoreForm);if(calculatorOptions.targetTraits.every(t=>!unitTargetTraits.includes(t)))return 1;const traitTreasureMult=unitTargetTraits.filter(t=>t in SETTINGS.traitEffectMult.trait&&calculatorOptions.targetTraits.includes(t)).map(t=>getTreasurePercent(SETTINGS.traitEffectMult.trait[t][0],SETTINGS.traitEffectMult.trait[t][1])).reduce((pre,curr)=>Math.max(pre,curr),0);let cumulativeMult=1;for(const ability of Object.keys(SETTINGS.traitEffectMult[statType]))if(hasAbility(ability,fixedData,updatedData,calculatorOptions.includeTalents,calculatorOptions.talentIgnoreForm)){const orbAddition=getEffectOrb(ability,calculatorOptions.targetTraits,updatedData).filter(o=>unitTargetTraits.includes(ORB_MAP.traits[o.trait])).reduce((prev,next)=>prev+ORB_MAP.type_mults[statType][ability][next.rank],0);let multiplier=SETTINGS.traitEffectMult[statType][ability][0]+traitTreasureMult*SETTINGS.traitEffectMult[statType][ability][1]/3;calculatorOptions.includeOrbs&&("def"===statType&&orbAddition>0?multiplier*=orbAddition:"atk"===statType&&orbAddition>0&&(multiplier+=orbAddition)),cumulativeMult*=multiplier}return cumulativeMult}export function getUnitTraitTargets(fixedData,updatedData,includeTalents,talentIgnoreForm){let targetTraits=new Set(fixedData.stats[updatedData.current_form].traits);for(const trait of SETTINGS.traits)!targetTraits.has(trait)&&hasAbility(`Target_${trait}`,fixedData,updatedData,includeTalents,talentIgnoreForm)&&targetTraits.add(trait);return[...targetTraits]}export function hasAbility(abilityName,fixedData,updatedData,includeTalents,talentIgnoreForm){let foundAbility=fixedData.stats[updatedData.current_form].abilities.includes(abilityName);if(includeTalents&&!foundAbility&&(talentIgnoreForm||updatedData.current_form>=2)){const talentIndex=fixedData.talents.findIndex(t=>t.name===abilityName);foundAbility=-1!==talentIndex&&1===updatedData.talents[talentIndex]}if(includeTalents&&!foundAbility&&(talentIgnoreForm||updatedData.current_form>=3)){const talentIndex=fixedData.ultra_talents.findIndex(t=>t.name===abilityName);foundAbility=-1!==talentIndex&&1===updatedData.ultra_talents[talentIndex]}return foundAbility}export function getEffectOrb(ability,targetTraits,updatedData){return updatedData.orb.filter(o=>o&&o.trait<ORB_MAP.traits.length&&targetTraits.includes(ORB_MAP.traits[o.trait])&&ORB_MAP.encoded_types[o.type]===ability)}export function getAbilityOrb(ability,updatedData){return updatedData.orb.filter(o=>o&&99===o.trait&&ORB_MAP.abilities[o.type]===ability)}export function getTalentStatMod(talentName,fixedData,updatedData,talentIgnoreForm){let mult=0;if(talentIgnoreForm||updatedData.current_form>=2)for(let x=0;x<fixedData.talents.length;x++)fixedData.talents[x].name===talentName&&(TALENT_GROWTH_MAP.talents[fixedData.id]?.[talentName]?"number"==typeof TALENT_GROWTH_MAP.talents[fixedData.id][talentName]?mult+=TALENT_GROWTH_MAP.talents[fixedData.id][talentName]*updatedData.talents[x]:(mult+=TALENT_GROWTH_MAP.talents[fixedData.id][talentName][0],mult+=TALENT_GROWTH_MAP.talents[fixedData.id][talentName][1]*updatedData.talents[x]):mult+=TALENT_GROWTH_MAP[talentName]*updatedData.talents[x]);if(talentIgnoreForm||updatedData.current_form>=3)for(let x=0;x<fixedData.ultra_talents.length;x++)fixedData.ultra_talents[x].name===talentName&&(TALENT_GROWTH_MAP.ultra_talents[fixedData.id]?.[talentName]?"number"==typeof TALENT_GROWTH_MAP.ultra_talents[fixedData.id][talentName]?mult+=TALENT_GROWTH_MAP.ultra_talents[fixedData.id][talentName]*updatedData.ultra_talents[x]:(mult+=TALENT_GROWTH_MAP.ultra_talents[fixedData.id][talentName][0],mult+=TALENT_GROWTH_MAP.ultra_talents[fixedData.id][talentName][1]*updatedData.ultra_talents[x]):mult+=TALENT_GROWTH_MAP[talentName]*updatedData.ultra_talents[x]);return mult}